\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{floatflt,epsfig}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry} 
\usepackage{titlesec}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinelanguage{XML}
{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  morecomment=[s][\color{green!50!black}]{<!--}{-->},
  stringstyle=\color{blue},
  identifierstyle=\color{red},
  keywordstyle=\color{orange},
  commentstyle=\color{green!50!black},
  basicstyle=\small\ttfamily,
  frame=single, 
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  showstringspaces=false,
  captionpos=b,
}

\lstdefinelanguage{Java}{
  keywords={abstract,assert,boolean,break,byte,case,catch,char,class,const,continue,default,do,double,else,enum,extends,false,final,finally,float,for,goto,if,implements,import,instanceof,int,interface,long,native,new,null,package,private,protected,public,return,short,static,strictfp,super,switch,synchronized,this,throw,throws,transient,true,try,void,volatile,while},
  morekeywords={[2]System,out},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  basicstyle=\small\ttfamily,
  keywordstyle=\color{blue}\bfseries,
  keywordstyle={[2]\color{orange}\bfseries},
  commentstyle=\color{green!70!black},
  stringstyle=\color{red},
  showstringspaces=false,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=true,
  frame=single, 
  captionpos=b
}


\titleformat{\section}
{\LARGE\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\Large\bfseries}{\thesection}{1em}{}

\begin{document}

\pagestyle{empty}

\section*{Views}
\large
\textbf{Android Views} è il paradigma standard per la creazione e manipolazione di tutti gli elementi grafici che compongano la \textit{User Interface}. Una \textbf{View} definisce un concetto primitivo ma essenziale per lo sviluppo di applicazioni, contenitrice di tutti gli oggetti visualizzati a schermo. Pertanto una \textit{View} è responsabile non solo della modellazione di tutti gli elementi grafici che caratterizzano l'applicazione di riferimento, ma anche della gestione degli eventi che li riguardano, come l'interazione con agenti esterni oppure l'acquisizione di dati.\vspace*{14pt}\\
Esempi più comuni di \textit{View} sono distinti in:
\begin{enumerate}
  \itemsep0em
  \renewcommand{\labelenumi}{-}
  \item \textbf{Widgets}, descritte come delle etichette, da non confondere con il sistema software già in uso all'interno di dispositivi mobili
  \item \textbf{Layouts}, insieme di caratteristiche grafiche e comportamentali    
\end{enumerate} 
Per determinare una \textit{View} si adottano due metodi essenziali:
\begin{enumerate}
  \itemsep0em
  \renewcommand{\labelenumi}{-}
  \item \textbf{Declarative method}, metodo dichiarativo di una \textit{View} tramite il file \textit{XML}, simile a quanto definito a livello di \textit{Activity}, in cui il \textit{Manifest} assume un'importanza essenziale. Il loro accesso tramite linguaggi di programmazione, \textit{Java} oppure \textit{Kotlin}, avviene tramite il metodo \textbf{findViewById} a cui è passato come parametro l'elemento grafico contenuto all'interno della medesima \textit{View}
  \item METTERE ESEMPIO DI SLIDE 5-6 
  \item \textbf{Programmatic View}, in questo ambito le \textit{View} sono direttamente create in \textit{Java} o \textit{Kotlin}, immettendo il \textit{contesto} di riferimento. Tuttavia si tratta di un approccio non raccomandato, a causa del fatto che nella sezione \textit{code} occorre dettare tutte le proprietà visive        
\end{enumerate} 

\subsection*{Handling Events}
La fase successiva ritrae la gestione degli eventi associati agli oggetti visivi. \textit{Java}/\textit{Kotlin} manipolano i possibili eventi attraverso la keyword \textbf{OnClick}; mediante la stessa definizione è possibile addirittura forzare l'avvenimento di un evento senza alcuna interazione.\vspace*{14pt}\\
Esistono tre differenti metodi per gestire gli eventi, suddivisi in:
\begin{enumerate}
  \itemsep0em
  \renewcommand{\labelenumi}{-}
  \item \textbf{XML}, il tutto gestito mediante le \textbf{callbacks}, direttamente indicate nel file; tuttavia il metodo descritto riguarda solamente un numero ristretto di componenti. \\METTERE ESEMPIO SLIDE 10
  \item \textbf{Event Handlers}, in questa sezione ogni \textit{View} contiene un ammontare di metodi, richiamati qualora dovesse verificarsi un evento. Le differenti funzioni citate sono frutto di innumerevoli \textit{extend} adattati nella classe \textit{View}, riferiti agli oggetti grafici, per cui tramite questo approccio occorre compiere molteplici \textit{override}; di conseguenza più articolata risulterà la \textit{View}, maggiore sarà l'\textit{impraticabilità}
  \item \textbf{Event Listeners}, in quest'ultima casistica, ogni \textit{View} delega l'implementazione del comportamento, successivo ad un certo evento, ad un oggetto. In tal senso, ogni \textit{listener} gestisce una singola tipologia di evento e contiene un unico metodo \textit{callback}. Si evince in questa breve descrizione la volontà di dividere nettamente ciò che è ritenuto dinamico, come l'interfaccia grafica, da elementi che costituiscono la logica dell'applicazione, ossia il comportamento successivo alla veridicità dell'evento, sovrapponendo un layer di astrazione in grado di isolare le due entità da modifiche e cambiamenti reciproci \\
  \begin{lstlisting}[language=JAVA, title=Gestione evento tramite Event Listener]
    Button button;
    class MainActivity extends AppCompatActivity implements OnClickListener{
      @Override
      protected void onCreate(Bunflr savedInstanceState) {
        ...
        button = findViewById(R.id.button1);
        button.setOnClickListener(this); 
      }

      @Override 
      void onClick(View v) { }
    }
  \end{lstlisting}
  Di seguito sono definiti brevemente gli aspetti salienti della sezione di codice riportata:
  \begin{itemize}
    \itemsep0em
    \item In questo esempio la \textit{MainActivity} implementa la classe astratta \textit{OnClickListener}, affinchè possa gestire correttamente gli eventi scaturiti da interazioni con agenti esterni
    \item All'interno del metodo \textit{onCreate()}, viene acquisito il bottone immesso all'interno della \textit{View}. In questo modo è possibile, attraverso il \textit{listener}, definire il comportamento del bottone una volta creato; si ricorda che la gestione e il coordinamento degli eventi avviene tramite la keyword \textit{OnClick}
    \item Infine all'interno del metodo \textit{onClick()}, da cui si osserva la keyword \textit{Override}, è sviluppata la vera logica del bottone, rispettando in questo modo la suddivisione in business logic e classi di alto livello descritta precedentemente. Nel caso in cui dovessero essere presenti più bottoni occorrerà implementare uno \textit{switch} che possa distinguere le possibili casistiche
  \end{itemize}
\end{enumerate}

\subsection*{Layout}
Un \textbf{Layout} deve estendere una \textbf{ViewGroup}. Una \textit{ViewGroup} è un contenitore di \textit{View} adottato per definire la struttura del loro \textit{Layout}. \vspace*{14pt}\\
Ogni \textit{View} in un \textit{Layout} deve specificare:
\begin{enumerate}
  \itemsep0em
  \renewcommand{\labelenumi}{-}
  \item Una \textit{lunghezza}, espressa in \textbf{android:layout\_height}
  \item Una \textit{larghezza}, espressa in \textbf{android:layout\_width} 
  \item Una \textit{dimensione}, espressa numericamente oppure staticamente tramite la sintassi \textit{match\_parent} oppure \textit{wrap\_content}
  \item METTERE ESEMPIO SLIDE 22
\end{enumerate}

\end{document}